// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'calculate_limit_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CalculateLimitEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() CalculateLimit,
    required TResult Function() GrantLimit,
    required TResult Function(String docUrl, RequiredDocument requiredDocument)
        AddDocumentUrl,
    required TResult Function(String programId) NextProgram,
    required TResult Function(String? calculateLimit, String changedLimit)
        UpdateLimit,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? CalculateLimit,
    TResult? Function()? GrantLimit,
    TResult? Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult? Function(String programId)? NextProgram,
    TResult? Function(String? calculateLimit, String changedLimit)? UpdateLimit,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? CalculateLimit,
    TResult Function()? GrantLimit,
    TResult Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult Function(String programId)? NextProgram,
    TResult Function(String? calculateLimit, String changedLimit)? UpdateLimit,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalculateLimit value) CalculateLimit,
    required TResult Function(GrantLimit value) GrantLimit,
    required TResult Function(AddDocumentUrl value) AddDocumentUrl,
    required TResult Function(NextProgram value) NextProgram,
    required TResult Function(UpdateLimit value) UpdateLimit,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalculateLimit value)? CalculateLimit,
    TResult? Function(GrantLimit value)? GrantLimit,
    TResult? Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult? Function(NextProgram value)? NextProgram,
    TResult? Function(UpdateLimit value)? UpdateLimit,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalculateLimit value)? CalculateLimit,
    TResult Function(GrantLimit value)? GrantLimit,
    TResult Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult Function(NextProgram value)? NextProgram,
    TResult Function(UpdateLimit value)? UpdateLimit,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalculateLimitEventCopyWith<$Res> {
  factory $CalculateLimitEventCopyWith(
          CalculateLimitEvent value, $Res Function(CalculateLimitEvent) then) =
      _$CalculateLimitEventCopyWithImpl<$Res, CalculateLimitEvent>;
}

/// @nodoc
class _$CalculateLimitEventCopyWithImpl<$Res, $Val extends CalculateLimitEvent>
    implements $CalculateLimitEventCopyWith<$Res> {
  _$CalculateLimitEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CalculateLimitImplCopyWith<$Res> {
  factory _$$CalculateLimitImplCopyWith(_$CalculateLimitImpl value,
          $Res Function(_$CalculateLimitImpl) then) =
      __$$CalculateLimitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CalculateLimitImplCopyWithImpl<$Res>
    extends _$CalculateLimitEventCopyWithImpl<$Res, _$CalculateLimitImpl>
    implements _$$CalculateLimitImplCopyWith<$Res> {
  __$$CalculateLimitImplCopyWithImpl(
      _$CalculateLimitImpl _value, $Res Function(_$CalculateLimitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CalculateLimitImpl implements CalculateLimit {
  const _$CalculateLimitImpl();

  @override
  String toString() {
    return 'CalculateLimitEvent.CalculateLimit()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CalculateLimitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() CalculateLimit,
    required TResult Function() GrantLimit,
    required TResult Function(String docUrl, RequiredDocument requiredDocument)
        AddDocumentUrl,
    required TResult Function(String programId) NextProgram,
    required TResult Function(String? calculateLimit, String changedLimit)
        UpdateLimit,
  }) {
    return CalculateLimit();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? CalculateLimit,
    TResult? Function()? GrantLimit,
    TResult? Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult? Function(String programId)? NextProgram,
    TResult? Function(String? calculateLimit, String changedLimit)? UpdateLimit,
  }) {
    return CalculateLimit?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? CalculateLimit,
    TResult Function()? GrantLimit,
    TResult Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult Function(String programId)? NextProgram,
    TResult Function(String? calculateLimit, String changedLimit)? UpdateLimit,
    required TResult orElse(),
  }) {
    if (CalculateLimit != null) {
      return CalculateLimit();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalculateLimit value) CalculateLimit,
    required TResult Function(GrantLimit value) GrantLimit,
    required TResult Function(AddDocumentUrl value) AddDocumentUrl,
    required TResult Function(NextProgram value) NextProgram,
    required TResult Function(UpdateLimit value) UpdateLimit,
  }) {
    return CalculateLimit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalculateLimit value)? CalculateLimit,
    TResult? Function(GrantLimit value)? GrantLimit,
    TResult? Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult? Function(NextProgram value)? NextProgram,
    TResult? Function(UpdateLimit value)? UpdateLimit,
  }) {
    return CalculateLimit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalculateLimit value)? CalculateLimit,
    TResult Function(GrantLimit value)? GrantLimit,
    TResult Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult Function(NextProgram value)? NextProgram,
    TResult Function(UpdateLimit value)? UpdateLimit,
    required TResult orElse(),
  }) {
    if (CalculateLimit != null) {
      return CalculateLimit(this);
    }
    return orElse();
  }
}

abstract class CalculateLimit implements CalculateLimitEvent {
  const factory CalculateLimit() = _$CalculateLimitImpl;
}

/// @nodoc
abstract class _$$GrantLimitImplCopyWith<$Res> {
  factory _$$GrantLimitImplCopyWith(
          _$GrantLimitImpl value, $Res Function(_$GrantLimitImpl) then) =
      __$$GrantLimitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GrantLimitImplCopyWithImpl<$Res>
    extends _$CalculateLimitEventCopyWithImpl<$Res, _$GrantLimitImpl>
    implements _$$GrantLimitImplCopyWith<$Res> {
  __$$GrantLimitImplCopyWithImpl(
      _$GrantLimitImpl _value, $Res Function(_$GrantLimitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GrantLimitImpl implements GrantLimit {
  const _$GrantLimitImpl();

  @override
  String toString() {
    return 'CalculateLimitEvent.GrantLimit()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GrantLimitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() CalculateLimit,
    required TResult Function() GrantLimit,
    required TResult Function(String docUrl, RequiredDocument requiredDocument)
        AddDocumentUrl,
    required TResult Function(String programId) NextProgram,
    required TResult Function(String? calculateLimit, String changedLimit)
        UpdateLimit,
  }) {
    return GrantLimit();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? CalculateLimit,
    TResult? Function()? GrantLimit,
    TResult? Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult? Function(String programId)? NextProgram,
    TResult? Function(String? calculateLimit, String changedLimit)? UpdateLimit,
  }) {
    return GrantLimit?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? CalculateLimit,
    TResult Function()? GrantLimit,
    TResult Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult Function(String programId)? NextProgram,
    TResult Function(String? calculateLimit, String changedLimit)? UpdateLimit,
    required TResult orElse(),
  }) {
    if (GrantLimit != null) {
      return GrantLimit();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalculateLimit value) CalculateLimit,
    required TResult Function(GrantLimit value) GrantLimit,
    required TResult Function(AddDocumentUrl value) AddDocumentUrl,
    required TResult Function(NextProgram value) NextProgram,
    required TResult Function(UpdateLimit value) UpdateLimit,
  }) {
    return GrantLimit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalculateLimit value)? CalculateLimit,
    TResult? Function(GrantLimit value)? GrantLimit,
    TResult? Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult? Function(NextProgram value)? NextProgram,
    TResult? Function(UpdateLimit value)? UpdateLimit,
  }) {
    return GrantLimit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalculateLimit value)? CalculateLimit,
    TResult Function(GrantLimit value)? GrantLimit,
    TResult Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult Function(NextProgram value)? NextProgram,
    TResult Function(UpdateLimit value)? UpdateLimit,
    required TResult orElse(),
  }) {
    if (GrantLimit != null) {
      return GrantLimit(this);
    }
    return orElse();
  }
}

abstract class GrantLimit implements CalculateLimitEvent {
  const factory GrantLimit() = _$GrantLimitImpl;
}

/// @nodoc
abstract class _$$AddDocumentUrlImplCopyWith<$Res> {
  factory _$$AddDocumentUrlImplCopyWith(_$AddDocumentUrlImpl value,
          $Res Function(_$AddDocumentUrlImpl) then) =
      __$$AddDocumentUrlImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String docUrl, RequiredDocument requiredDocument});

  $RequiredDocumentCopyWith<$Res> get requiredDocument;
}

/// @nodoc
class __$$AddDocumentUrlImplCopyWithImpl<$Res>
    extends _$CalculateLimitEventCopyWithImpl<$Res, _$AddDocumentUrlImpl>
    implements _$$AddDocumentUrlImplCopyWith<$Res> {
  __$$AddDocumentUrlImplCopyWithImpl(
      _$AddDocumentUrlImpl _value, $Res Function(_$AddDocumentUrlImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? docUrl = null,
    Object? requiredDocument = null,
  }) {
    return _then(_$AddDocumentUrlImpl(
      docUrl: null == docUrl
          ? _value.docUrl
          : docUrl // ignore: cast_nullable_to_non_nullable
              as String,
      requiredDocument: null == requiredDocument
          ? _value.requiredDocument
          : requiredDocument // ignore: cast_nullable_to_non_nullable
              as RequiredDocument,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RequiredDocumentCopyWith<$Res> get requiredDocument {
    return $RequiredDocumentCopyWith<$Res>(_value.requiredDocument, (value) {
      return _then(_value.copyWith(requiredDocument: value));
    });
  }
}

/// @nodoc

class _$AddDocumentUrlImpl implements AddDocumentUrl {
  const _$AddDocumentUrlImpl(
      {required this.docUrl, required this.requiredDocument});

  @override
  final String docUrl;
  @override
  final RequiredDocument requiredDocument;

  @override
  String toString() {
    return 'CalculateLimitEvent.AddDocumentUrl(docUrl: $docUrl, requiredDocument: $requiredDocument)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddDocumentUrlImpl &&
            (identical(other.docUrl, docUrl) || other.docUrl == docUrl) &&
            (identical(other.requiredDocument, requiredDocument) ||
                other.requiredDocument == requiredDocument));
  }

  @override
  int get hashCode => Object.hash(runtimeType, docUrl, requiredDocument);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddDocumentUrlImplCopyWith<_$AddDocumentUrlImpl> get copyWith =>
      __$$AddDocumentUrlImplCopyWithImpl<_$AddDocumentUrlImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() CalculateLimit,
    required TResult Function() GrantLimit,
    required TResult Function(String docUrl, RequiredDocument requiredDocument)
        AddDocumentUrl,
    required TResult Function(String programId) NextProgram,
    required TResult Function(String? calculateLimit, String changedLimit)
        UpdateLimit,
  }) {
    return AddDocumentUrl(docUrl, requiredDocument);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? CalculateLimit,
    TResult? Function()? GrantLimit,
    TResult? Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult? Function(String programId)? NextProgram,
    TResult? Function(String? calculateLimit, String changedLimit)? UpdateLimit,
  }) {
    return AddDocumentUrl?.call(docUrl, requiredDocument);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? CalculateLimit,
    TResult Function()? GrantLimit,
    TResult Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult Function(String programId)? NextProgram,
    TResult Function(String? calculateLimit, String changedLimit)? UpdateLimit,
    required TResult orElse(),
  }) {
    if (AddDocumentUrl != null) {
      return AddDocumentUrl(docUrl, requiredDocument);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalculateLimit value) CalculateLimit,
    required TResult Function(GrantLimit value) GrantLimit,
    required TResult Function(AddDocumentUrl value) AddDocumentUrl,
    required TResult Function(NextProgram value) NextProgram,
    required TResult Function(UpdateLimit value) UpdateLimit,
  }) {
    return AddDocumentUrl(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalculateLimit value)? CalculateLimit,
    TResult? Function(GrantLimit value)? GrantLimit,
    TResult? Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult? Function(NextProgram value)? NextProgram,
    TResult? Function(UpdateLimit value)? UpdateLimit,
  }) {
    return AddDocumentUrl?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalculateLimit value)? CalculateLimit,
    TResult Function(GrantLimit value)? GrantLimit,
    TResult Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult Function(NextProgram value)? NextProgram,
    TResult Function(UpdateLimit value)? UpdateLimit,
    required TResult orElse(),
  }) {
    if (AddDocumentUrl != null) {
      return AddDocumentUrl(this);
    }
    return orElse();
  }
}

abstract class AddDocumentUrl implements CalculateLimitEvent {
  const factory AddDocumentUrl(
      {required final String docUrl,
      required final RequiredDocument requiredDocument}) = _$AddDocumentUrlImpl;

  String get docUrl;
  RequiredDocument get requiredDocument;
  @JsonKey(ignore: true)
  _$$AddDocumentUrlImplCopyWith<_$AddDocumentUrlImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NextProgramImplCopyWith<$Res> {
  factory _$$NextProgramImplCopyWith(
          _$NextProgramImpl value, $Res Function(_$NextProgramImpl) then) =
      __$$NextProgramImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String programId});
}

/// @nodoc
class __$$NextProgramImplCopyWithImpl<$Res>
    extends _$CalculateLimitEventCopyWithImpl<$Res, _$NextProgramImpl>
    implements _$$NextProgramImplCopyWith<$Res> {
  __$$NextProgramImplCopyWithImpl(
      _$NextProgramImpl _value, $Res Function(_$NextProgramImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? programId = null,
  }) {
    return _then(_$NextProgramImpl(
      programId: null == programId
          ? _value.programId
          : programId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$NextProgramImpl implements NextProgram {
  const _$NextProgramImpl({required this.programId});

  @override
  final String programId;

  @override
  String toString() {
    return 'CalculateLimitEvent.NextProgram(programId: $programId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NextProgramImpl &&
            (identical(other.programId, programId) ||
                other.programId == programId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, programId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NextProgramImplCopyWith<_$NextProgramImpl> get copyWith =>
      __$$NextProgramImplCopyWithImpl<_$NextProgramImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() CalculateLimit,
    required TResult Function() GrantLimit,
    required TResult Function(String docUrl, RequiredDocument requiredDocument)
        AddDocumentUrl,
    required TResult Function(String programId) NextProgram,
    required TResult Function(String? calculateLimit, String changedLimit)
        UpdateLimit,
  }) {
    return NextProgram(programId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? CalculateLimit,
    TResult? Function()? GrantLimit,
    TResult? Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult? Function(String programId)? NextProgram,
    TResult? Function(String? calculateLimit, String changedLimit)? UpdateLimit,
  }) {
    return NextProgram?.call(programId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? CalculateLimit,
    TResult Function()? GrantLimit,
    TResult Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult Function(String programId)? NextProgram,
    TResult Function(String? calculateLimit, String changedLimit)? UpdateLimit,
    required TResult orElse(),
  }) {
    if (NextProgram != null) {
      return NextProgram(programId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalculateLimit value) CalculateLimit,
    required TResult Function(GrantLimit value) GrantLimit,
    required TResult Function(AddDocumentUrl value) AddDocumentUrl,
    required TResult Function(NextProgram value) NextProgram,
    required TResult Function(UpdateLimit value) UpdateLimit,
  }) {
    return NextProgram(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalculateLimit value)? CalculateLimit,
    TResult? Function(GrantLimit value)? GrantLimit,
    TResult? Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult? Function(NextProgram value)? NextProgram,
    TResult? Function(UpdateLimit value)? UpdateLimit,
  }) {
    return NextProgram?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalculateLimit value)? CalculateLimit,
    TResult Function(GrantLimit value)? GrantLimit,
    TResult Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult Function(NextProgram value)? NextProgram,
    TResult Function(UpdateLimit value)? UpdateLimit,
    required TResult orElse(),
  }) {
    if (NextProgram != null) {
      return NextProgram(this);
    }
    return orElse();
  }
}

abstract class NextProgram implements CalculateLimitEvent {
  const factory NextProgram({required final String programId}) =
      _$NextProgramImpl;

  String get programId;
  @JsonKey(ignore: true)
  _$$NextProgramImplCopyWith<_$NextProgramImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateLimitImplCopyWith<$Res> {
  factory _$$UpdateLimitImplCopyWith(
          _$UpdateLimitImpl value, $Res Function(_$UpdateLimitImpl) then) =
      __$$UpdateLimitImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? calculateLimit, String changedLimit});
}

/// @nodoc
class __$$UpdateLimitImplCopyWithImpl<$Res>
    extends _$CalculateLimitEventCopyWithImpl<$Res, _$UpdateLimitImpl>
    implements _$$UpdateLimitImplCopyWith<$Res> {
  __$$UpdateLimitImplCopyWithImpl(
      _$UpdateLimitImpl _value, $Res Function(_$UpdateLimitImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? calculateLimit = freezed,
    Object? changedLimit = null,
  }) {
    return _then(_$UpdateLimitImpl(
      calculateLimit: freezed == calculateLimit
          ? _value.calculateLimit
          : calculateLimit // ignore: cast_nullable_to_non_nullable
              as String?,
      changedLimit: null == changedLimit
          ? _value.changedLimit
          : changedLimit // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UpdateLimitImpl implements UpdateLimit {
  const _$UpdateLimitImpl({this.calculateLimit, required this.changedLimit});

  @override
  final String? calculateLimit;
  @override
  final String changedLimit;

  @override
  String toString() {
    return 'CalculateLimitEvent.UpdateLimit(calculateLimit: $calculateLimit, changedLimit: $changedLimit)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateLimitImpl &&
            (identical(other.calculateLimit, calculateLimit) ||
                other.calculateLimit == calculateLimit) &&
            (identical(other.changedLimit, changedLimit) ||
                other.changedLimit == changedLimit));
  }

  @override
  int get hashCode => Object.hash(runtimeType, calculateLimit, changedLimit);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateLimitImplCopyWith<_$UpdateLimitImpl> get copyWith =>
      __$$UpdateLimitImplCopyWithImpl<_$UpdateLimitImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() CalculateLimit,
    required TResult Function() GrantLimit,
    required TResult Function(String docUrl, RequiredDocument requiredDocument)
        AddDocumentUrl,
    required TResult Function(String programId) NextProgram,
    required TResult Function(String? calculateLimit, String changedLimit)
        UpdateLimit,
  }) {
    return UpdateLimit(calculateLimit, changedLimit);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? CalculateLimit,
    TResult? Function()? GrantLimit,
    TResult? Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult? Function(String programId)? NextProgram,
    TResult? Function(String? calculateLimit, String changedLimit)? UpdateLimit,
  }) {
    return UpdateLimit?.call(calculateLimit, changedLimit);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? CalculateLimit,
    TResult Function()? GrantLimit,
    TResult Function(String docUrl, RequiredDocument requiredDocument)?
        AddDocumentUrl,
    TResult Function(String programId)? NextProgram,
    TResult Function(String? calculateLimit, String changedLimit)? UpdateLimit,
    required TResult orElse(),
  }) {
    if (UpdateLimit != null) {
      return UpdateLimit(calculateLimit, changedLimit);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CalculateLimit value) CalculateLimit,
    required TResult Function(GrantLimit value) GrantLimit,
    required TResult Function(AddDocumentUrl value) AddDocumentUrl,
    required TResult Function(NextProgram value) NextProgram,
    required TResult Function(UpdateLimit value) UpdateLimit,
  }) {
    return UpdateLimit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CalculateLimit value)? CalculateLimit,
    TResult? Function(GrantLimit value)? GrantLimit,
    TResult? Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult? Function(NextProgram value)? NextProgram,
    TResult? Function(UpdateLimit value)? UpdateLimit,
  }) {
    return UpdateLimit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CalculateLimit value)? CalculateLimit,
    TResult Function(GrantLimit value)? GrantLimit,
    TResult Function(AddDocumentUrl value)? AddDocumentUrl,
    TResult Function(NextProgram value)? NextProgram,
    TResult Function(UpdateLimit value)? UpdateLimit,
    required TResult orElse(),
  }) {
    if (UpdateLimit != null) {
      return UpdateLimit(this);
    }
    return orElse();
  }
}

abstract class UpdateLimit implements CalculateLimitEvent {
  const factory UpdateLimit(
      {final String? calculateLimit,
      required final String changedLimit}) = _$UpdateLimitImpl;

  String? get calculateLimit;
  String get changedLimit;
  @JsonKey(ignore: true)
  _$$UpdateLimitImplCopyWith<_$UpdateLimitImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CalculateLimitState {
  RequestState get requestState => throw _privateConstructorUsedError;
  List<ProgramModel> get programs => throw _privateConstructorUsedError;
  List<RequiredDocument> get documentsURLs =>
      throw _privateConstructorUsedError;
  ErrorPayload? get errorPayload => throw _privateConstructorUsedError;
  ProgramModel? get currentProgram => throw _privateConstructorUsedError;
  String get calculatedLimit => throw _privateConstructorUsedError;
  String get changedLimit => throw _privateConstructorUsedError;
  bool get shouldHideSkipButton => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CalculateLimitStateCopyWith<CalculateLimitState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalculateLimitStateCopyWith<$Res> {
  factory $CalculateLimitStateCopyWith(
          CalculateLimitState value, $Res Function(CalculateLimitState) then) =
      _$CalculateLimitStateCopyWithImpl<$Res, CalculateLimitState>;
  @useResult
  $Res call(
      {RequestState requestState,
      List<ProgramModel> programs,
      List<RequiredDocument> documentsURLs,
      ErrorPayload? errorPayload,
      ProgramModel? currentProgram,
      String calculatedLimit,
      String changedLimit,
      bool shouldHideSkipButton});

  $ErrorPayloadCopyWith<$Res>? get errorPayload;
  $ProgramModelCopyWith<$Res>? get currentProgram;
}

/// @nodoc
class _$CalculateLimitStateCopyWithImpl<$Res, $Val extends CalculateLimitState>
    implements $CalculateLimitStateCopyWith<$Res> {
  _$CalculateLimitStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requestState = null,
    Object? programs = null,
    Object? documentsURLs = null,
    Object? errorPayload = freezed,
    Object? currentProgram = freezed,
    Object? calculatedLimit = null,
    Object? changedLimit = null,
    Object? shouldHideSkipButton = null,
  }) {
    return _then(_value.copyWith(
      requestState: null == requestState
          ? _value.requestState
          : requestState // ignore: cast_nullable_to_non_nullable
              as RequestState,
      programs: null == programs
          ? _value.programs
          : programs // ignore: cast_nullable_to_non_nullable
              as List<ProgramModel>,
      documentsURLs: null == documentsURLs
          ? _value.documentsURLs
          : documentsURLs // ignore: cast_nullable_to_non_nullable
              as List<RequiredDocument>,
      errorPayload: freezed == errorPayload
          ? _value.errorPayload
          : errorPayload // ignore: cast_nullable_to_non_nullable
              as ErrorPayload?,
      currentProgram: freezed == currentProgram
          ? _value.currentProgram
          : currentProgram // ignore: cast_nullable_to_non_nullable
              as ProgramModel?,
      calculatedLimit: null == calculatedLimit
          ? _value.calculatedLimit
          : calculatedLimit // ignore: cast_nullable_to_non_nullable
              as String,
      changedLimit: null == changedLimit
          ? _value.changedLimit
          : changedLimit // ignore: cast_nullable_to_non_nullable
              as String,
      shouldHideSkipButton: null == shouldHideSkipButton
          ? _value.shouldHideSkipButton
          : shouldHideSkipButton // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ErrorPayloadCopyWith<$Res>? get errorPayload {
    if (_value.errorPayload == null) {
      return null;
    }

    return $ErrorPayloadCopyWith<$Res>(_value.errorPayload!, (value) {
      return _then(_value.copyWith(errorPayload: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ProgramModelCopyWith<$Res>? get currentProgram {
    if (_value.currentProgram == null) {
      return null;
    }

    return $ProgramModelCopyWith<$Res>(_value.currentProgram!, (value) {
      return _then(_value.copyWith(currentProgram: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CalculateLimitStateImplCopyWith<$Res>
    implements $CalculateLimitStateCopyWith<$Res> {
  factory _$$CalculateLimitStateImplCopyWith(_$CalculateLimitStateImpl value,
          $Res Function(_$CalculateLimitStateImpl) then) =
      __$$CalculateLimitStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {RequestState requestState,
      List<ProgramModel> programs,
      List<RequiredDocument> documentsURLs,
      ErrorPayload? errorPayload,
      ProgramModel? currentProgram,
      String calculatedLimit,
      String changedLimit,
      bool shouldHideSkipButton});

  @override
  $ErrorPayloadCopyWith<$Res>? get errorPayload;
  @override
  $ProgramModelCopyWith<$Res>? get currentProgram;
}

/// @nodoc
class __$$CalculateLimitStateImplCopyWithImpl<$Res>
    extends _$CalculateLimitStateCopyWithImpl<$Res, _$CalculateLimitStateImpl>
    implements _$$CalculateLimitStateImplCopyWith<$Res> {
  __$$CalculateLimitStateImplCopyWithImpl(_$CalculateLimitStateImpl _value,
      $Res Function(_$CalculateLimitStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requestState = null,
    Object? programs = null,
    Object? documentsURLs = null,
    Object? errorPayload = freezed,
    Object? currentProgram = freezed,
    Object? calculatedLimit = null,
    Object? changedLimit = null,
    Object? shouldHideSkipButton = null,
  }) {
    return _then(_$CalculateLimitStateImpl(
      requestState: null == requestState
          ? _value.requestState
          : requestState // ignore: cast_nullable_to_non_nullable
              as RequestState,
      programs: null == programs
          ? _value._programs
          : programs // ignore: cast_nullable_to_non_nullable
              as List<ProgramModel>,
      documentsURLs: null == documentsURLs
          ? _value._documentsURLs
          : documentsURLs // ignore: cast_nullable_to_non_nullable
              as List<RequiredDocument>,
      errorPayload: freezed == errorPayload
          ? _value.errorPayload
          : errorPayload // ignore: cast_nullable_to_non_nullable
              as ErrorPayload?,
      currentProgram: freezed == currentProgram
          ? _value.currentProgram
          : currentProgram // ignore: cast_nullable_to_non_nullable
              as ProgramModel?,
      calculatedLimit: null == calculatedLimit
          ? _value.calculatedLimit
          : calculatedLimit // ignore: cast_nullable_to_non_nullable
              as String,
      changedLimit: null == changedLimit
          ? _value.changedLimit
          : changedLimit // ignore: cast_nullable_to_non_nullable
              as String,
      shouldHideSkipButton: null == shouldHideSkipButton
          ? _value.shouldHideSkipButton
          : shouldHideSkipButton // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$CalculateLimitStateImpl implements _CalculateLimitState {
  const _$CalculateLimitStateImpl(
      {this.requestState = RequestState.initial,
      final List<ProgramModel> programs = const [],
      final List<RequiredDocument> documentsURLs = const [],
      this.errorPayload,
      this.currentProgram,
      this.calculatedLimit = "",
      this.changedLimit = "",
      this.shouldHideSkipButton = false})
      : _programs = programs,
        _documentsURLs = documentsURLs;

  @override
  @JsonKey()
  final RequestState requestState;
  final List<ProgramModel> _programs;
  @override
  @JsonKey()
  List<ProgramModel> get programs {
    if (_programs is EqualUnmodifiableListView) return _programs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_programs);
  }

  final List<RequiredDocument> _documentsURLs;
  @override
  @JsonKey()
  List<RequiredDocument> get documentsURLs {
    if (_documentsURLs is EqualUnmodifiableListView) return _documentsURLs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_documentsURLs);
  }

  @override
  final ErrorPayload? errorPayload;
  @override
  final ProgramModel? currentProgram;
  @override
  @JsonKey()
  final String calculatedLimit;
  @override
  @JsonKey()
  final String changedLimit;
  @override
  @JsonKey()
  final bool shouldHideSkipButton;

  @override
  String toString() {
    return 'CalculateLimitState(requestState: $requestState, programs: $programs, documentsURLs: $documentsURLs, errorPayload: $errorPayload, currentProgram: $currentProgram, calculatedLimit: $calculatedLimit, changedLimit: $changedLimit, shouldHideSkipButton: $shouldHideSkipButton)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalculateLimitStateImpl &&
            (identical(other.requestState, requestState) ||
                other.requestState == requestState) &&
            const DeepCollectionEquality().equals(other._programs, _programs) &&
            const DeepCollectionEquality()
                .equals(other._documentsURLs, _documentsURLs) &&
            (identical(other.errorPayload, errorPayload) ||
                other.errorPayload == errorPayload) &&
            (identical(other.currentProgram, currentProgram) ||
                other.currentProgram == currentProgram) &&
            (identical(other.calculatedLimit, calculatedLimit) ||
                other.calculatedLimit == calculatedLimit) &&
            (identical(other.changedLimit, changedLimit) ||
                other.changedLimit == changedLimit) &&
            (identical(other.shouldHideSkipButton, shouldHideSkipButton) ||
                other.shouldHideSkipButton == shouldHideSkipButton));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      requestState,
      const DeepCollectionEquality().hash(_programs),
      const DeepCollectionEquality().hash(_documentsURLs),
      errorPayload,
      currentProgram,
      calculatedLimit,
      changedLimit,
      shouldHideSkipButton);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CalculateLimitStateImplCopyWith<_$CalculateLimitStateImpl> get copyWith =>
      __$$CalculateLimitStateImplCopyWithImpl<_$CalculateLimitStateImpl>(
          this, _$identity);
}

abstract class _CalculateLimitState implements CalculateLimitState {
  const factory _CalculateLimitState(
      {final RequestState requestState,
      final List<ProgramModel> programs,
      final List<RequiredDocument> documentsURLs,
      final ErrorPayload? errorPayload,
      final ProgramModel? currentProgram,
      final String calculatedLimit,
      final String changedLimit,
      final bool shouldHideSkipButton}) = _$CalculateLimitStateImpl;

  @override
  RequestState get requestState;
  @override
  List<ProgramModel> get programs;
  @override
  List<RequiredDocument> get documentsURLs;
  @override
  ErrorPayload? get errorPayload;
  @override
  ProgramModel? get currentProgram;
  @override
  String get calculatedLimit;
  @override
  String get changedLimit;
  @override
  bool get shouldHideSkipButton;
  @override
  @JsonKey(ignore: true)
  _$$CalculateLimitStateImplCopyWith<_$CalculateLimitStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
